### 零、初衷
2020/08/15 周六

希望自己可以坚持下去，将设计模式学习透彻。


### 一、学习

#### 1、单例 - SingleTon

> src/main/java/singleton

通过定义一个私有访问权限的构造函数，避免被其它类 new 出来一个对象，同时提供给一个访问该对象的静态方法。

在使用过程中，注意考虑到线程安全即可。

推荐使用 饿汉式单例 singleton.SingleTon_01

在 Spring 中，每个 Bean 默认就是单例的，这样做的优点是 Spring 容器可以管理这些 Bean 的生命期，决定什么时候创建，什么时候销毁，销毁的时候要如何处理，等等。


#### 2、模板 - TemplateMethod

> src/main/java/templateMehtod

定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

~~钩子函数（回调函数），感觉是利用了 Java 特性之一：多态~~

如果想要子类去控制某些步骤，可以通过钩子方法，简单的实现可以是某一步执行的前提是某个 boolean 属性必须为 true,同时还可以在子类中添加修改此属性的方法。

有一个较常见的问题是： "父类如何调用子类的方法？"这个问题换个角度去理解，父类建立框架，子类在重写了父类部分的方法后，再调用从父类继承的方法，产生不同的结果，（而这正是模板方法模式）也可以理解为父类调用了子类的方法。


#### 3、策略 - Strategy

> src/main/java/stragety

JDK 里面典型~~两个~~接口:

- ~~public interface Comparator<T>;
    比较两个 Object~~
- public interface Comparable<T>;
    与另一个比较

定义一组算法，将每个算法都封装起来，并且是它们之间可以互换。

**使用的就是面向对象的继承和多态机制**

==注意==

策略模式很容易造成策略类膨胀（每一个策略都是一个类，复用的可能性很小，类数量增多）。
建议：如果系统中的一个策略家族的具体策略数量超过 4 个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露问题，否则日后的系统维护就会成为一个烫手山芋。



